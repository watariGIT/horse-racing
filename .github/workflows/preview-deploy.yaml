name: PR Preview Deploy & Validation

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, labeled]

concurrency:
  group: preview-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  GCP_REGION: us-central1
  GCP_PROJECT_ID: horse-racing-ml-dev
  CLOUD_RUN_JOB: ml-pipeline-preview

jobs:
  docker-build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t ml-pipeline-test .

  preview-deploy:
    if: contains(github.event.pull_request.labels.*.name, 'preview-deploy')
    needs: docker-build
    runs-on: ubuntu-latest
    timeout-minutes: 90
    permissions:
      contents: read
      id-token: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Build and push Docker image
        run: |
          IMAGE=${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/ml-pipeline/ml-pipeline:pr-${{ github.event.pull_request.number }}
          docker build -t "${IMAGE}" .
          docker push "${IMAGE}"

      - name: Deploy to Cloud Run Jobs
        run: |
          IMAGE=${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/ml-pipeline/ml-pipeline:pr-${{ github.event.pull_request.number }}
          gcloud run jobs deploy ${{ env.CLOUD_RUN_JOB }} \
            --image "${IMAGE}" \
            --region ${{ env.GCP_REGION }} \
            --project ${{ env.GCP_PROJECT_ID }} \
            --memory 2Gi \
            --cpu 1 \
            --max-retries 0 \
            --task-timeout 3600 \
            --service-account ${{ secrets.SERVICE_ACCOUNT }} \
            --set-env-vars "ENVIRONMENT=dev,GCP_PROJECT_ID=${{ env.GCP_PROJECT_ID }},PIPELINE_DATA_SOURCE=bigquery"

      - name: Execute pipeline
        id: execute
        run: |
          gcloud run jobs execute ${{ env.CLOUD_RUN_JOB }} \
            --region ${{ env.GCP_REGION }} \
            --project ${{ env.GCP_PROJECT_ID }} \
            --wait

      - name: Fetch backtest report
        id: report
        if: always()
        run: |
          REPORT_JSON=$(gsutil cat gs://horse-racing-ml-dev-processed/reports/backtest_report.json 2>/dev/null || echo '{}')
          echo "report_json<<REPORT_EOF" >> "$GITHUB_OUTPUT"
          echo "${REPORT_JSON}" >> "$GITHUB_OUTPUT"
          echo "REPORT_EOF" >> "$GITHUB_OUTPUT"

      - name: Post PR comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- preview-deploy-report -->';
            const sha = context.sha.substring(0, 7);
            const image = `${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/ml-pipeline/ml-pipeline:pr-${{ github.event.pull_request.number }}`;
            const executeOutcome = '${{ steps.execute.outcome }}';
            const status = executeOutcome === 'success' ? 'Success' : 'Failed';

            // Parse report
            let metricsTable = '';
            let fullReport = '';
            try {
              const reportJson = JSON.parse(`${{ steps.report.outputs.report_json }}`);
              if (reportJson.report) {
                fullReport = reportJson.report;
                // Extract key metrics from markdown tables
                const lines = fullReport.split('\n');
                const metrics = {};
                let inTable = false;
                for (const line of lines) {
                  if (line.startsWith('| Metric')) {
                    inTable = true;
                    continue;
                  }
                  if (line.startsWith('|---')) continue;
                  if (inTable && line.startsWith('|')) {
                    const cols = line.split('|').map(c => c.trim()).filter(Boolean);
                    if (cols.length >= 2) {
                      metrics[cols[0]] = cols[1];
                    }
                  } else {
                    inTable = false;
                  }
                }
                if (Object.keys(metrics).length > 0) {
                  metricsTable = '### Key Metrics\n| Metric | Value |\n|--------|-------|\n';
                  for (const [k, v] of Object.entries(metrics)) {
                    metricsTable += `| ${k} | ${v} |\n`;
                  }
                }
              }
            } catch (e) {
              // Report parsing failed - not critical
            }

            if (!metricsTable) {
              metricsTable = '_No report available_';
            }

            let reportDetails = '';
            if (fullReport) {
              reportDetails = `\n<details>\n<summary>Full Backtest Report</summary>\n\n${fullReport}\n</details>`;
            }

            const body = `${marker}
            ## Pipeline Preview Report

            **Status**: ${status}
            **Commit**: \`${sha}\`
            **Image**: \`${image}\`

            ${metricsTable}
            ${reportDetails}`.replace(/^            /gm, '');

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }
